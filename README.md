Шаблон сервиса на Go
===========================================
С развитием любого проекта, логика работы приложения усложняется и запутывается.
Разработка новых фич замедляется. Если не планировать архитектуру, довольно быстро
приходит время, когда переписать сервис становится дешевле, чем делать изменения в
существующем.

Цели:
1. Предоставить готовый шаблон для быстрого развертывания
2. Стандартизировать подходы к организации кода
3. Аккумулировать лучшие практики

Quick start
----
Скопировать и переименовать файл `.env.example` в `.env`.

Локальная разработка:
```sh
# Postgres, RabbitMQ
$ make compose-up
# Run app with migrations
$ make run
```

Интеграционные тесты (можно запускать в ci):
```sh
# DB, app + migrations, integration tests
$ make compose-up-integration-test
```

Clean Architecture
----
### Главный принцип
Dependency Inversion (тот самый из SOLID) — принцип инверсии зависимостей, играет
ключевую роль в построении архитектуры приложения. Чтобы принцип начал работать,
нам нужно поделить приложение на слои.

![Clean Architecture](docs/img/layers.png)

Итак, приложение делится на 2 слоя, внутренний и внешний:
1. **Бизнес-логика** (стандартная библиотека Go).
2. **Инструменты** (база данных, HTTP сервер, брокер сообщений, любые другие пакеты
и фреймворки).

**Внутренний** слой с бизнес-логикой должен быть чистым, то есть:
- Не иметь в себе импортов пакетов из внешнего слоя.
- Не иметь в себе импортов любых других пакетов, кроме стандартной библиотеки.
- Делать обращения к внешнему слою через интерфейс(!).

Бизнес-логика ничего не знает о Postgres или RabbitMQ. Бизнес-логика знает
интерфейс для работы с _абстрактной_ базой данных, _абстрактным_ брокером
сообщений или _абстрактным_ web api.

**Внешний** слой имеет другие ограничения:
- Все компоненты этого слоя не знают о существовании друг друга.
- Как из одного инструмента вызвать другой? Напрямую никак, только через
внутренний слой логики.
- Обращения к внутреннему слою происходят через интерфейс(!).
- Данные передаются в том формате, который удобен для бизнес-логики.

**Например**, вам нужно обратиться из http хендлера к базе данных. И http, и
БД находятся во внешнем слое, значит они ничего не знают друг о друге. Связь
между ними осуществляется через `service` (бизнес-логику):
```
    HTTP (delivery) > service
                      service > Postrges (repo)
                      service < Postrges (repo)
    HTTP (delivery) < service
```
Стрелочками > и < показано пересечение границ слоев через Интерфейсы.

То же самое на картинке:

![Example](docs/img/example-http-db.png)

### Терминология Чистой Архитектуры
- **Entities** — объекты, которыми оперирует бизнес-логика. В коде называются
по именам принятым в организации. Находятся в папке `internal/domain`. Domain
намекает на то что мы придерживаемся принципов DDD (domain driven design), это
отчасти так, но без фанатизма. В терминах MVC entity это модели. Удобно когда
модели называются по именам предметной области.


- **Use Cases** — это бизнес-логика, манипулирующая внешними пакетами через
интерфейсы. Находится в папке `internal/service`. Называть бизнес-логику словом
_service_ не очень идеоматично с точки зрения Чистой Архитектуры, но слово
_service_ удобнее использовать для названия пакета, чем _usecase_.

Слой с которым непосредственно взаимодействует бизнес-логика обычно называют
инфраструктурным слоем - _infrastructure_. Это могут быть репозитории
`internal/service/repo`, внешние webapi `internal/service/webapi`, любые pkg
и другие 
микросервисы. В шаблоне инфраструктурные пакеты находятся внутри каталога
`internal/service`.

Как называть точки входа, вопрос открыт. Варианты:
- delivery
- transport
- controllers
- adaptors
- gateways
- input
- entry_points
- primary

### Dependency Injection
Для того чтобы убрать зависимость бизнес-логики от внешних пакетов, используется
инъекция зависимостей.

Через конструктор NewService мы делаем инъекцию зависимости в структуру бизнес-логики.
Таким образом бизнес-логика становится независимой (и даже переносимой). Мы можем
подменить реализацию интерфейса и при этом не вносить правки в пакет `service`.

```go
package service

import (
    // Nothing!
)

type Repository interface {
    Get()
}

type Service struct {
    repo Repository
}

func NewService(r Repository) *Service{
    return &Service{r}
}

func (s *Service) Do()  {
    s.repo.Get()
}
```
Это так же позволит нам делать автогенерацию моков (например с помощью библиотеки
_mockery_) и легко писать юнит-тесты.

### Дополнительные слои
Классический вариант [Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
разрабатывался для построения больших монолитных приложений и имеет 4 слоя абстракций.

То есть, в оригинальной версии, внешний слой делится ещё на два, которые
так же имеют обратную инверсию зависимостей друг к другу (направленную во внутрь)
и общаются через интерфейсы.

Внутренний слой так же делится на два (с разделением интерфейсов), в случае
сложной логики.
_______________________________

Сложные инструменты из внешнего слоя рекомендуется делить на дополнительные
слои абстракции. Следует руководствоваться здравым смыслом и добавлять слои
лишь в том случае, если это действительно необходимо.

### Альтернативные подходы
Кроме Чистой архитектуры есть очень близкие по духу — Луковая архитектура и
Гексагональная (Порты и адаптеры). В основе всех подходов лежит базовый принцип
инверсии зависимостей. Все подходы преследуют цель уменьшить зацепление и
разграничить ответственность.

Полезные ссылки
---------------
- [The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Книга Чистая архитектура](https://www.ozon.ru/context/detail/id/144499396/)
- [12 факторов](https://12factor.net/ru/)